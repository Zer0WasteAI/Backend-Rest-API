"""
üéØ TEST DE PRECISI√ìN CON IM√ÅGENES ESPEC√çFICAS
===========================================

Test para evaluar la precisi√≥n del reconocimiento con:
- ensalada.jpg (comida preparada)
- pollo_con_mani.jpg (comida preparada) 
- ceviche_peruano.jpg (ingredientes crudos)

Con logs detallados de responses y an√°lisis de precisi√≥n.
"""

import unittest
import time
import json
from pathlib import Path
from io import BytesIO
from datetime import datetime

# Importar el servicio directamente
import sys
sys.path.append(str(Path(__file__).parent.parent.parent))

from src.infrastructure.ai.gemini_adapter_service import GeminiAdapterService


class TestPrecisionSpecificImages(unittest.TestCase):
    """Test de precisi√≥n con im√°genes espec√≠ficas"""
    
    def setUp(self):
        """Configuraci√≥n para cada test"""
        self.ai_service = GeminiAdapterService()
        self.foods_dir = Path(__file__).parent.parent / "images" / "foods"
        
        # Im√°genes espec√≠ficas a probar
        self.ensalada_path = self.foods_dir / "ensalada.jpg"
        self.pollo_path = self.foods_dir / "pollo_con_mani.jpg"
        self.ceviche_path = self.foods_dir / "ceviche_peruano.jpg"
        
        # Verificar que las im√°genes existen
        for path in [self.ensalada_path, self.pollo_path, self.ceviche_path]:
            if not path.exists():
                self.skipTest(f"‚ùå No se encontr√≥ {path.name}")
        
        print(f"\nüéØ INICIANDO TEST DE PRECISI√ìN")
        print(f"üìÖ Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 60)
    
    def _load_image_as_bytes(self, image_path: Path):
        """Cargar imagen como BytesIO"""
        with open(image_path, 'rb') as f:
            image_data = f.read()
        return BytesIO(image_data)
    
    def _format_time(self, seconds):
        """Formatear tiempo en forma legible"""
        if seconds < 1:
            return f"{seconds*1000:.0f}ms"
        else:
            return f"{seconds:.2f}s"
    
    def _print_detailed_response(self, response, title, exec_time):
        """Imprimir response detallado con formato"""
        print(f"\nüìã {title}")
        print("=" * len(title))
        print(f"‚è±Ô∏è Tiempo de procesamiento: {self._format_time(exec_time)}")
        print("\nüîç RESPONSE COMPLETO:")
        print("-" * 40)
        print(json.dumps(response, indent=2, ensure_ascii=False))
        print("-" * 40)
    
    def _measure_and_analyze(self, func, image_bytes, image_name, recognition_type):
        """Medir tiempo y analizar response"""
        print(f"\n‚è∞ Iniciando {recognition_type} para {image_name}...")
        
        start_time = time.time()
        result = func([image_bytes])
        end_time = time.time()
        exec_time = end_time - start_time
        
        print(f"‚úÖ Completado en: {self._format_time(exec_time)}")
        return result, exec_time
    
    def test_ensalada_recognition_detailed(self):
        """Test detallado con ensalada.jpg (comida preparada)"""
        print(f"\nü•ó AN√ÅLISIS DETALLADO: ENSALADA.JPG")
        print("=" * 50)
        print("üì∑ Tipo esperado: COMIDA PREPARADA")
        print("üéØ Debe detectar: Foods ‚úÖ | No debe detectar: Ingredients ‚ùå")
        
        ensalada_bytes = self._load_image_as_bytes(self.ensalada_path)
        
        # Test Foods Recognition
        foods_result, foods_time = self._measure_and_analyze(
            self.ai_service.recognize_foods, 
            ensalada_bytes, 
            "ensalada.jpg", 
            "FOODS Recognition"
        )
        
        self._print_detailed_response(
            foods_result, 
            "FOODS RECOGNITION - ENSALADA", 
            foods_time
        )
        
        # Test Ingredients Recognition
        ingredients_result, ingredients_time = self._measure_and_analyze(
            self.ai_service.recognize_ingredients, 
            ensalada_bytes, 
            "ensalada.jpg", 
            "INGREDIENTS Recognition"
        )
        
        self._print_detailed_response(
            ingredients_result, 
            "INGREDIENTS RECOGNITION - ENSALADA", 
            ingredients_time
        )
        
        # An√°lisis de precisi√≥n
        foods_count = len(foods_result.get('foods', []))
        ingredients_count = len(ingredients_result.get('ingredients', []))
        
        print(f"\nüìä AN√ÅLISIS DE PRECISI√ìN - ENSALADA:")
        print(f"   ‚Ä¢ Foods detectados: {foods_count} (esperado: >0)")
        print(f"   ‚Ä¢ Ingredients detectados: {ingredients_count} (esperado: 0)")
        
        if foods_count > 0:
            print(f"   ‚Ä¢ ‚úÖ CORRECTO: Detect√≥ ensalada como comida preparada")
            for i, food in enumerate(foods_result.get('foods', [])):
                print(f"     {i+1}. {food.get('name', 'N/A')}")
                print(f"        Categor√≠a: {food.get('category', 'N/A')}")
                print(f"        Calor√≠as: {food.get('calories', 'N/A')}")
        else:
            print(f"   ‚Ä¢ ‚ùå ERROR: No detect√≥ ensalada como comida")
        
        if ingredients_count == 0:
            print(f"   ‚Ä¢ ‚úÖ CORRECTO: No detect√≥ ensalada como ingredientes")
        else:
            print(f"   ‚Ä¢ ‚ö†Ô∏è INESPERADO: Detect√≥ ensalada como ingredientes")
    
    def test_pollo_con_mani_recognition_detailed(self):
        """Test detallado con pollo_con_mani.jpg (comida preparada)"""
        print(f"\nüçó AN√ÅLISIS DETALLADO: POLLO_CON_MANI.JPG")
        print("=" * 55)
        print("üì∑ Tipo esperado: COMIDA PREPARADA")
        print("üéØ Debe detectar: Foods ‚úÖ | No debe detectar: Ingredients ‚ùå")
        
        pollo_bytes = self._load_image_as_bytes(self.pollo_path)
        
        # Test Foods Recognition
        foods_result, foods_time = self._measure_and_analyze(
            self.ai_service.recognize_foods, 
            pollo_bytes, 
            "pollo_con_mani.jpg", 
            "FOODS Recognition"
        )
        
        self._print_detailed_response(
            foods_result, 
            "FOODS RECOGNITION - POLLO CON MAN√ç", 
            foods_time
        )
        
        # Test Ingredients Recognition
        ingredients_result, ingredients_time = self._measure_and_analyze(
            self.ai_service.recognize_ingredients, 
            pollo_bytes, 
            "pollo_con_mani.jpg", 
            "INGREDIENTS Recognition"
        )
        
        self._print_detailed_response(
            ingredients_result, 
            "INGREDIENTS RECOGNITION - POLLO CON MAN√ç", 
            ingredients_time
        )
        
        # An√°lisis de precisi√≥n
        foods_count = len(foods_result.get('foods', []))
        ingredients_count = len(ingredients_result.get('ingredients', []))
        
        print(f"\nüìä AN√ÅLISIS DE PRECISI√ìN - POLLO CON MAN√ç:")
        print(f"   ‚Ä¢ Foods detectados: {foods_count} (esperado: >0)")
        print(f"   ‚Ä¢ Ingredients detectados: {ingredients_count} (esperado: 0)")
        
        if foods_count > 0:
            print(f"   ‚Ä¢ ‚úÖ CORRECTO: Detect√≥ pollo como comida preparada")
            for i, food in enumerate(foods_result.get('foods', [])):
                print(f"     {i+1}. {food.get('name', 'N/A')}")
                print(f"        Categor√≠a: {food.get('category', 'N/A')}")
                print(f"        Calor√≠as: {food.get('calories', 'N/A')}")
                print(f"        Ingredientes: {', '.join(food.get('main_ingredients', []))}")
        else:
            print(f"   ‚Ä¢ ‚ùå ERROR: No detect√≥ pollo como comida")
        
        if ingredients_count == 0:
            print(f"   ‚Ä¢ ‚úÖ CORRECTO: No detect√≥ pollo como ingredientes")
        else:
            print(f"   ‚Ä¢ ‚ö†Ô∏è INESPERADO: Detect√≥ pollo como ingredientes")
    
    def test_ceviche_ingredients_recognition_detailed(self):
        """Test detallado con ceviche_peruano.jpg (ingredientes crudos)"""
        print(f"\nüêü AN√ÅLISIS DETALLADO: CEVICHE_PERUANO.JPG")
        print("=" * 55)
        print("üì∑ Tipo esperado: INGREDIENTES CRUDOS")
        print("üéØ Debe detectar: Ingredients ‚úÖ | No debe detectar: Foods ‚ùå")
        
        ceviche_bytes = self._load_image_as_bytes(self.ceviche_path)
        
        # Test Ingredients Recognition
        ingredients_result, ingredients_time = self._measure_and_analyze(
            self.ai_service.recognize_ingredients, 
            ceviche_bytes, 
            "ceviche_peruano.jpg", 
            "INGREDIENTS Recognition"
        )
        
        self._print_detailed_response(
            ingredients_result, 
            "INGREDIENTS RECOGNITION - CEVICHE INGREDIENTES", 
            ingredients_time
        )
        
        # Test Foods Recognition
        foods_result, foods_time = self._measure_and_analyze(
            self.ai_service.recognize_foods, 
            ceviche_bytes, 
            "ceviche_peruano.jpg", 
            "FOODS Recognition"
        )
        
        self._print_detailed_response(
            foods_result, 
            "FOODS RECOGNITION - CEVICHE INGREDIENTES", 
            foods_time
        )
        
        # An√°lisis de precisi√≥n
        ingredients_count = len(ingredients_result.get('ingredients', []))
        foods_count = len(foods_result.get('foods', []))
        
        print(f"\nüìä AN√ÅLISIS DE PRECISI√ìN - CEVICHE INGREDIENTES:")
        print(f"   ‚Ä¢ Ingredients detectados: {ingredients_count} (esperado: >0)")
        print(f"   ‚Ä¢ Foods detectados: {foods_count} (esperado: 0)")
        
        if ingredients_count > 0:
            print(f"   ‚Ä¢ ‚úÖ CORRECTO: Detect√≥ ingredientes crudos")
            for i, ing in enumerate(ingredients_result.get('ingredients', [])):
                print(f"     {i+1}. {ing.get('name', 'N/A')}")
                print(f"        Cantidad: {ing.get('quantity', 'N/A')} {ing.get('type_unit', '')}")
                print(f"        Almacenamiento: {ing.get('storage_type', 'N/A')}")
        else:
            print(f"   ‚Ä¢ ‚ùå ERROR: No detect√≥ ingredientes crudos")
        
        if foods_count == 0:
            print(f"   ‚Ä¢ ‚úÖ CORRECTO: No detect√≥ ingredientes como comida")
        else:
            print(f"   ‚Ä¢ ‚ö†Ô∏è INESPERADO: Detect√≥ ingredientes como comida")
            for i, food in enumerate(foods_result.get('foods', [])):
                print(f"     {i+1}. {food.get('name', 'N/A')}")
    
    def test_precision_summary(self):
        """Resumen final de precisi√≥n y performance"""
        print(f"\nüéØ RESUMEN FINAL DE PRECISI√ìN")
        print("=" * 40)
        print("üìä Resultados esperados:")
        print("   ‚Ä¢ Ensalada ‚Üí Foods: ‚úÖ | Ingredients: ‚ùå")
        print("   ‚Ä¢ Pollo ‚Üí Foods: ‚úÖ | Ingredients: ‚ùå") 
        print("   ‚Ä¢ Ceviche ‚Üí Ingredients: ‚úÖ | Foods: ‚ùå")
        print("\nüí° Todos los tests completados. Revisa los logs detallados arriba.")


if __name__ == '__main__':
    # Ejecutar tests en orden espec√≠fico
    unittest.main(verbosity=2) 